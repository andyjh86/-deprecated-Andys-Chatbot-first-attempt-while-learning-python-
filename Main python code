import csv
import os.path
import tkinter as tk
from transformers import AutoModelForCausalLM, AutoTokenizer
import torch

model_name = "microsoft/DialoGPT-medium"
tokenizer = AutoTokenizer.from_pretrained(model_name, cache_dir="C:/Zoo/tokenizer-cache", padding_side='left')
model = AutoModelForCausalLM.from_pretrained(model_name, cache_dir="C:/Zoo/model-cache")
chat_history_ids = torch.tensor([])
downvoted_responses = set()

def get_response(event=None):
    global chat_history_ids, downvoted_responses
    # Get the message from the entry box
    message = entry.get()
    # Insert the message in the text widget
    conversation.insert(tk.END, f"You: {message}\n")
    # Encode the user input
    input_ids = tokenizer.encode(message + tokenizer.eos_token, return_tensors="pt")
    # concatenate new user input with chat history (if there is)
    bot_input_ids = torch.cat([chat_history_ids, input_ids], dim=-1) if len(chat_history_ids) > 0 else input_ids
    # generate a bot response
    while True:
        chat_history_ids = model.generate(
            bot_input_ids,
            max_length=1000,
            do_sample=True,
            top_k=100,
            temperature=0.75,
            pad_token_id=tokenizer.eos_token_id
        )
        # print the output
        response_text = tokenizer.decode(chat_history_ids[:, bot_input_ids.shape[-1]:][0], skip_special_tokens=True)
        # Check if the response has been previously downvoted
        if response_text not in downvoted_responses:
            break
    # Insert the response in the text widget
    conversation.insert(tk.END, f"Bot: {response_text}\n")
    # Clear the entry box
    entry.delete(0, tk.END)
    # Move the view to the end of the text widget
    conversation.see(tk.END)
    # Save and load upvotes for the bot's responses
    voting_file = "C:/Zoo/Voting/votes.csv"
    response = [message, response_text]
    if os.path.isfile(voting_file):
        with open(voting_file, 'r', newline='') as f:
            reader = csv.reader(f)
            for row in reader:
                if row[:2] == response:
                    upvotes = int(row[2])
                    downvotes = int(row[3])
                    break
            else:
                upvotes = 0
                downvotes = 0
    else:
        upvotes = 0
        downvotes = 0
        with open(voting_file, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Input', 'Response', 'Upvotes', 'Downvotes'])
    # enable upvote and downvote buttons
    upvote_button.config(state='normal')
    downvote_button.config(state='normal')

    # wait for upvote or downvote button to be clicked
    button_clicked = None
    def on_click(button):
        nonlocal button_clicked
        button_clicked = button

    upvote_button.config(command=lambda: on_click(upvote_button))
    downvote_button.config(command=lambda: on_click(downvote_button))

    while button_clicked is None:
        root.update()

    upvote_button.config(command=lambda: None)
    downvote_button.config(command=lambda: None)
    if button_clicked == upvote_button:
         if upvotes >= downvotes:
             upvotes += 1
         else:
            upvotes += 1
            downvotes -= 1
    elif button_clicked == downvote_button:
         if downvotes >= upvotes:
             downvotes += 1
         else:
           downvotes += 1
           upvotes -= 1
    with open(voting_file, 'a', newline='') as f:
         writer = csv.writer(f)
         writer.writerow(response + [upvotes, downvotes])
     # Disable upvote and downvote buttons
    upvote_button.config(state='disabled')
    downvote_button.config(state='disabled')

 # Create the main window
root = tk.Tk()
root.geometry("600x450")
root.title("Andy's Chatbot GUI")

 # Create a Text widget to show the conversation history
conversation = tk.Text(root)
conversation.pack(expand=True, fill='both')

 # Create an entry box
entry = tk.Entry(root)
entry.pack()

# Create a button
button = tk.Button(root, text="Get Response", command=get_response)
button.pack()

# Create upvote and downvote buttons
upvote_button = tk.Button(root, text='Upvote', state='disabled')
upvote_button.pack(side='left')
downvote_button = tk.Button(root, text='Downvote', state='disabled')
downvote_button.pack(side='right')

 # bind the enter key to the entry box
root.bind('<Return>', get_response)

# Start the main event loop
root.mainloop()
